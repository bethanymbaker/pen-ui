I'm working on a modeling system that uses Box2D to simulate physical
constraints to determine the location of vertices. For my purposes it
seems like I ought to be able to use just distance and revolute
joints.

For example, if I have these constraints (illustrated in the attachments):

A, B, and F are points
Distance from F to A is D units
Distance from F to B is also D units
The angle formed by the lines AF and BF is 90 degrees

I'm modeling the last constraint with a revolute joint (which might be
a completely wrong use of that joint type). Here is my code for that
establishes this part:

  private void buildJoint() {
    RevoluteJointDef angleDef = new RevoluteJointDef();
    angleDef.bodyA = thingA;
    angleDef.bodyB = thingB;
    angleDef.localAnchorA = spot(thingA); // points to fulcrum from thingA
    angleDef.localAnchorB = spot(thingB); // points to fulcrum from thingB
    angleDef.lowerAngle = (float) Math.toRadians(90);
    angleDef.upperAngle = (float) Math.toRadians(90);
    angleDef.enableLimit = true;
    angleJoint = (RevoluteJoint) m_world.createJoint(angleDef);
  }

  /*
   * Gives a vector that points from 'who' to the fulcrum so we can anchor 'who'.
   */
  private Vec2 spot(Body who) {
    Vec2 a = who.getWorldCenter();
    Vec2 b = fulcrum.getWorldCenter();
    Vec2 ret = new Vec2(-a.x + b.x, -a.y + b.y);
    return ret;
  }

The immediate problem (misunderstanding?) is that the fulcrum is
subject to other forces, and it moves around. Once the simulation has
begun, the angle constraint no longer uses the fulcrum's current
location as the local anchor.

I've tried destroying and recreating the revolute joint on each
iteration to get it to use the fulcrum's actual location, but this
does wonky things as well. The length constraints do the right thing
but the angle constraint converges to the wrong number. Here's the
iteration function:

  public void step(TestbedSettings settings) {
    super.step(settings);
    float fToA = MathUtils.distance(fulcrum.getPosition(), thingA.getPosition());
    float fToB = MathUtils.distance(fulcrum.getPosition(), thingB.getPosition());
    addTextLine("Fulcrum to A: " + Debug.num(fToA)); // converges to the correct value
    addTextLine("Fulcrum to B: " + Debug.num(fToB)); // converges to the correct value
    m_world.destroyJoint(angleJointABC);
    addTextLine("Angle: " + getDebugAngleDegrees()); // converges to the wrong value
    buildJoint(); // set up joint for next iteration
  }



Bugs at the moment:

- GlassPane mousePressed: the mouse point is not being converted to
  the same reference. make sure the gesture's coordinate system and
  the mouse point's system are the same.

- after completing a move gesture, something isn't getting cleaned up
  because pen events are not being generated.

- When a pen enter/exit event is received, make sure to react
  accordingly when gesturing.

- implement drawing buffer layers gesture complete

- Implement grid gesture handler for gesture complete



Critical path:

(1) Draw stuff [done]

(2) Analyze input, find corners and identify segment types (line,
ellipse, other curve) [done]

(3) Identify and act on latching opportunities---forms stencils

(4) Identify and act on encircle gestures

(5) Identify and act on drag-to-grid gestures

(6) Allow stencils to be placed in cutfile pane

(7) Generate cutfile from stencils in cutfile pane

+------------------------------------------------------------------------+
|				NOTES                                    |
+------------------------------------------------------------------------+

Constraint solver is in org.six11.util.spud

Junction finding code is in org.six11.util.tmp2 (I moved it out of the
six11utils codebase though since they are mostly just experiments. The
code is in ~/Projects/junction-finders on my laptop now)

+------------------------------------------------------------------------+
|			   SHORT TERM TODO				 |
+------------------------------------------------------------------------+

* Make bezel surrounding sketch area

* Think about general event structure for...
  - goal crossing
  - pen activity (mostly have this already)

+------------------------------------------------------------------------+
|		       HARD OR UNCLEAR PROBLEMS				 |
+------------------------------------------------------------------------+

* Zooming: Need to be able to have an infinite drawing surface that is
  shown on a finite screen. User will be able to scroll around and
  zoom in/out. Conceivable many objects are offscreen, so I need to be
  smart about how I render this. Maybe: each graphic element has a
  pre-computed bounding box, and I can just query a data structure for
  all the graphic elements whose bounding boxes intersect with the
  screen.

* Undo: Is this even a thing I need to support?

* Rendering: How much do I cache? And when I am rendering, how should
  I deal with the problem of placing an image at a non-integer
  coordinate? This comes up especially when zooming.

* Constraint solving: I have the spud classes, but this is still
  basically untested and fragile. If I can't get that to work I'm not
  sure what I will do.


+------------------------------------------------------------------------+
|			   LONG TERM GOALS				 |
+------------------------------------------------------------------------+

* Application supports three main activities:

  1) Thinking about what to make---supports free sketching anywhere on
  canvas without recognition getting in the way

  2) Specifying details---supports free sketching intended to be
  recognized periodically at user request

  3) Creating a cutfile---adding detailed stencils to a parts list
  that is automatically layed out on material whose dimensions are
  user-defined

* Interface has three main areas

  1) Drawing canvas with a bezel that gives context-specific functions
  (e.g. panning)

  2) Scrap grid that lets users place sketch fragments. Scraps are for:
     
     - Bookmarks to easily find and return to prior sketches
     - For copying existing fragments onto drawing canvas
     - For activating a fragment to edit its details
     - For copying fragments (that include stencils) into the cutfile region

  3) Cutfile region to define material size and add stencils. Used to
  generate models ready to laser-cut.

* Canvas, in 'thinking mode'

  - Draw anywhere in 'pencil'.
  - Uses a single, infinite-page metaphor
  - Navigate canvas by either
    + using the bezel to pan around (drag gesture)
    + using scrap grid to navigate to earlier sketches
  - Can circle a region, which is recognized but no active action is taken

* Scrap grid

  - See earlier sketches placed in grid
  - When user circles something in thinking mode canvas, grid lights up
  - Tap empty space in grid to add an encircled sketch fragment
  - Adding fragment causes circle to go away
  - Tap grid cell with fragment to zoom to its location and highlight it
  - Drag fragment onto drawing canvas to copy contents to new location
  - Double-tap fragment to enter 'specification mode'

* Canvas, in 'specification mode' --- mostly covered in the earlier video

  - visually distinct from 'thinking mode' (e.g. border color or grid lines)
  - shows pencil marks in light color, recognized elements in dark
  - Recognition on demand (via gesture, onscreen button, offhand button)
  - I assume offhand button is best
  - Input recognized as one of:
    + Unrecognizable
    + Stencil lines (== laser cut path)
    + Text (== parameter names or dimension values)
    + Guides (reference points, guide lines)
    + Selections (overtracing or flow-selecting)
    + Camera gesture (double-circle to zoom in/out)
  - Selections used as recognition hints, useful for making isomorphic items
  - Bezel lets users turn up/down pencil mark opacity
  - Can add fragments (pencil or structured) by dragging from scrap grid

* Cutfile region

  - Drag structured fragments here to indicate atomic parts for cutting
  - System will automatically arrange them
  - User can see cutfile contents by dragging outward from cutfile region
  - User can edit the material dimensions in a bezel widget
  - User can create a final PDF or whatever using bezel widget


Some things that are still murky

1) Unclear how the user will see rough sketches at same time as making
   specification drawing. This would be useful. Maybe on a large
   screen this problem goes away.

2) Would like to be able to have multiple cut files, possibly in a
   sort of gallery or album metaphor within the cutfile widget. I
   often have a series of related cutfiles that I'm working on and
   need to edit them separately (e.g. picture frame stencils in one,
   and stencils for a frame stand in another)

3) Not sure how fluid it is transitioning between thinking and
   specification modes. Can they co-exist on the same canvas but just
   in different regions?

4) Unsure how to present recognition results when they are ambiguous,
   or how to choose among them, or how to recover from recognition
   error.  

   --> I had a really nice redo/undo widget in my SkruiDraw app that
       might be useful for recovering from both recognition errors and
       botched sketch marks.
